# 飞秋通讯项目 - 详细重构计划

创建时间: 2026-01-29
基于架构分析报告: `.sisyphus/notepads/refactor-analysis/架构分析报告.md`

---

## 一、重构设计原则

### 1.1 分层原则

- **前端层**（React）：只负责 UI 展示和用户交互
- **Hook 层**：负责 IPC 调用和请求管理
- **Store 层**：只负责状态管理，不包含业务逻辑
- **IPC 层**（薄层）：只负责参数转换和错误映射
- **Service 层**（业务逻辑层）：包含所有业务逻辑
- **Repository 层**：数据访问层
- **Database 层**：SeaORM ORM 层
- **Network 层**：协议实现和 UDP 网络
- **Event Bus**：细粒度事件，订阅者模式

### 1.2 单一职责原则

每个模块只做一件事，职责清晰明确：

- IPC 层：参数转换 + 错误映射
- Service 层：业务逻辑编排
- Repository 层：数据 CRUD
- Hook 层：API 调用封装

### 1.3 兼容性原则

- IPC 接口保持不变
- 前端最小化修改
- 渐进式迁移，每个阶段可独立回滚

### 1.4 测试驱动原则

- 每个阶段完成后立即测试
- 保证现有功能不被破坏
- 新功能有单元测试覆盖

---

## 二、目标架构设计

### 2.1 后端架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     Frontend (React)                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │
│  │  组件层   │→ │  Hook层  │→ │ Store层  │→ │ UI展示  │ │
│  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │
└───────────────────────────────────────┬─────────────────────┘
                                        │ IPC Commands
                                        ▼
┌─────────────────────────────────────────────────────────────┐
│                   IPC Layer (薄层)                        │
│  - 参数转换 (Frontend Types ↔ Domain Types)              │
│  - 错误映射 (AppError ↔ FrontendError)                  │
│  - 请求分发                                             │
└───────────────────────────────────────┬─────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────┐
│                 Service Layer (业务逻辑层)                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ChatService  │  │ContactService│  │FileService  │    │
│  │ - 发送消息  │  │ - 用户发现   │  │ - 文件传输  │    │
│  │ - 接收消息  │  │ - 联系人管理 │  │ - 传输管理  │    │
│  │ - 已读回执  │  │             │  │             │    │
│  └─────────────┘  └─────────────┘  └─────────────┘    │
│  ┌─────────────┐  ┌─────────────┐                      │
│  │GroupService │  │UserService  │                      │
│  │ - 群组管理  │  │ - 用户管理   │                      │
│  │ - 成员管理  │  │             │                      │
│  └─────────────┘  └─────────────┘                      │
└───────────────────────────────────────┬─────────────────┘
                                        │
                    ┌───────────────────┴───────────────────┐
                    ▼                                       ▼
┌─────────────────────────────┐           ┌─────────────────────────────┐
│    Repository Layer        │           │    Network Layer          │
│  (数据访问层)             │           │  (协议 + UDP)             │
│  ┌───────────────────┐    │           │  ┌──────────────────────┐ │
│  │ChatRepository     │    │           │  │Protocol Parser      │ │
│  │UserRepository    │    │           │  │Packet Packer       │ │
│  │FileRepository    │    │           │  │UDP Sender/Receiver │ │
│  └───────────────────┘    │           │  └──────────────────────┘ │
└──────────────┬────────────┘           └────────────┬────────────┘
               │                                      │
               ▼                                      ▼
┌─────────────────────────────┐           ┌─────────────────────────────┐
│     Database Layer         │           │      Event Bus            │
│  (SeaORM + SQLite)       │           │  (细粒度事件)             │
│  - chat_message           │           │  - MessageReceived        │
│  - user                  │           │  - UserOnline            │
│  - contact               │           │  - UserOffline           │
│  - group                │           │  - ReadReceiptReceived    │
│  - file_storage          │           │                          │
└─────────────────────────┘           └───────────────────────────┘
```

### 2.2 前端架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    UI Components                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐│
│  │ChatWindow│  │Contact  │  │FileUpload│  │MainLayout││
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘│
│       │            │            │            │           │
└───────┴────────────┴────────────┴────────────┴───────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                    Hooks Layer                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ useChat     │  │ useContact  │  │ useFile     │   │
│  │ - 发送消息  │  │ - 获取列表  │  │ - 上传文件  │   │
│  │ - 获取消息  │  │ - 添加联系人│  │ - 下载文件  │   │
│  │ - 标记已读  │  │             │  │             │   │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘   │
│         │                │                │              │
└─────────┴────────────────┴────────────────┴──────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                 IPC Client Layer                          │
│  - 统一的 IPC 调用封装                                │
│  - 请求取消机制                                         │
│  - 统一错误处理                                         │
└───────────────────────────────────────┬─────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────┐
│                   Store Layer                            │
│  - chatStore                                           │
│  - userStore                                           │
│  - index.ts                                            │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、分阶段重构计划

### 阶段 1：创建 Service 层骨架（1-2 天）

#### 目标

建立清晰的 Service 层结构，不破坏现有功能

#### 具体步骤

**步骤 1.1：创建 ChatService 骨架**

```bash
touch src-tauri/src/core/chat/service.rs
```

在 `service.rs` 中：

```rust
//! 聊天业务逻辑层

use crate::database::handler::*;
use crate::error::{AppError, AppResult};
use crate::types::*;

/// 聊天服务
pub struct ChatService;

impl ChatService {
    /// 发送消息
    pub async fn send_message(db: &DbConn, params: SendMessageParams) -> AppResult<i64> {
        todo!("实现发送消息逻辑")
    }

    /// 获取消息列表
    pub async fn get_messages(db: &DbConn, params: GetMessagesParams) -> AppResult<Vec<Message>> {
        todo!("实现获取消息逻辑")
    }

    /// 标记消息为已读
    pub async fn mark_as_read(db: &DbConn, msg_ids: Vec<i64>) -> AppResult<()> {
        todo!("实现标记已读逻辑")
    }

    /// 删除消息
    pub async fn delete_message(db: &DbConn, msg_id: i64) -> AppResult<()> {
        todo!("实现删除消息逻辑")
    }

    /// 获取会话列表
    pub async fn get_sessions(db: &DbConn, owner_uid: i64) -> AppResult<Vec<Session>> {
        todo!("实现获取会话逻辑")
    }

    /// 删除会话
    pub async fn delete_session(db: &DbConn, session_id: i64) -> AppResult<()> {
        todo!("实现删除会话逻辑")
    }
}
```

**步骤 1.2：创建 ContactService 骨架**

```bash
touch src-tauri/src/core/contact/service.rs
```

在 `service.rs` 中：

```rust
//! 联系人业务逻辑层

/// 联系人服务
pub struct ContactService;

impl ContactService {
    pub async fn get_contacts(db: &DbConn, owner_uid: i64) -> AppResult<Vec<Contact>> {
        todo!("实现获取联系人逻辑")
    }

    pub async fn add_contact(db: &DbConn, params: AddContactParams) -> AppResult<i64> {
        todo!("实现添加联系人逻辑")
    }

    pub async fn update_contact(db: &DbConn, params: UpdateContactParams) -> AppResult<()> {
        todo!("实现更新联系人逻辑")
    }

    pub async fn delete_contact(db: &DbConn, id: i64) -> AppResult<()> {
        todo!("实现删除联系人逻辑")
    }
}
```

**步骤 1.3：创建 FileService 骨架**

```bash
touch src-tauri/src/core/file/service.rs
```

在 `service.rs` 中：

```rust
//! 文件传输业务逻辑层

/// 文件服务
pub struct FileService;

impl FileService {
    pub async fn send_file_request(db: &DbConn, params: SendFileParams) -> AppResult<i64> {
        todo!("实现发送文件请求逻辑")
    }

    pub async fn accept_file(db: &DbConn, transfer_id: i64) -> AppResult<()> {
        todo!("实现接受文件逻辑")
    }

    pub async fn reject_file(db: &DbConn, transfer_id: i64) -> AppResult<()> {
        todo!("实现拒绝文件逻辑")
    }

    pub async fn cancel_transfer(db: &DbConn, transfer_id: i64) -> AppResult<()> {
        todo!("实现取消传输逻辑")
    }
}
```

**步骤 1.4：创建 GroupService 骨架**

```bash
touch src-tauri/src/core/group/service.rs
```

在 `service.rs` 中：

```rust
//! 群组业务逻辑层

/// 群组服务
pub struct GroupService;

impl GroupService {
    pub async fn create_group(db: &DbConn, params: CreateGroupParams) -> AppResult<i64> {
        todo!("实现创建群组逻辑")
    }

    pub async fn get_groups(db: &DbConn, owner_uid: i64) -> AppResult<Vec<Group>> {
        todo!("实现获取群组逻辑")
    }

    pub async fn add_member(db: &DbConn, params: AddMemberParams) -> AppResult<()> {
        todo!("实现添加成员逻辑")
    }

    pub async fn remove_member(db: &DbConn, params: RemoveMemberParams) -> AppResult<()> {
        todo!("实现移除成员逻辑")
    }
}
```

**步骤 1.5：更新模块导出**
在 `src-tauri/src/core/mod.rs` 中：

```rust
pub mod chat;
pub mod contact;
pub mod file;
pub mod group;

// 导出 Service
pub use chat::service::ChatService;
pub use contact::service::ContactService;
pub use file::service::FileService;
pub use group::service::GroupService;
```

#### 验收标准

- [ ] 所有 Service 文件编译通过
- [ ] Service 方法签名清晰，包含文档注释
- [ ] 现有功能不受影响（运行 `bun run tauri dev` 无错误）
- [ ] 所有现有测试通过（`cargo test`）

#### 回滚方案

删除新创建的 Service 文件，恢复 `core/mod.rs` 原始版本

---

### 阶段 2：迁移聊天业务逻辑（2-3 天）

#### 目标

将 `ipc/chat.rs` 的业务逻辑迁移到 `ChatService`

#### 具体步骤

**步骤 2.1：实现 ChatService::send_message**

从 `ipc/chat.rs::send_text_message_handler` 提取业务逻辑：

```rust
impl ChatService {
    /// 发送文本消息
    pub async fn send_message(db: &DbConn, params: SendMessageParams) -> AppResult<i64> {
        // 1. 创建消息记录
        let message = chat_message::ActiveModel {
            session_type: Set(params.session_type),
            target_id: Set(params.target_id),
            sender_uid: Set(params.sender_uid),
            msg_type: Set(0), // 文本消息
            content: Set(params.content.clone()),
            send_time: Set(Utc::now().to_rfc3339()),
            status: Set(0),
            msg_no: Set(Some(params.msg_no)),
            ..Default::default()
        };
        let message = message.insert(db).await?;

        // 2. 获取或创建会话
        let session = ChatSessionHandler::get_or_create(db, params.sender_uid, params.session_type, params.target_id).await?;

        // 3. 更新会话最后消息
        ChatSessionHandler::update_last_message(db, session.sid, message.mid).await?;

        // 4. 发送网络消息
        let packet = FeiqPacket::make_message_packet(&params.content, true);
        if params.session_type == 1 {
            // 群聊广播
            GroupBroadcaster::broadcast_message(db, params.target_id, &packet, params.sender_uid).await?;
        } else {
            // 单聊发送
            let target_user = UserHandler::find_by_id(db, params.target_id).await?;
            let addr = format!("{}:{}", target_user.feiq_ip, target_user.feiq_port);
            sender::send_packet(&addr, &packet).await?;
        }

        // 5. 发布事件
        EVENT_SENDER.send(AppEvent::Ui(UiEvent::MessageSent {
            mid: message.mid,
            session_id: session.sid,
            content: params.content,
        })).map_err(|e| AppError::EventBus(e.to_string()))?;

        Ok(message.mid)
    }
}
```

**步骤 2.2：实现其他 ChatService 方法**

- `get_messages`
- `mark_as_read`
- `delete_message`
- `get_sessions`
- `delete_session`

**步骤 2.3：重构 ipc/chat.rs**

```rust
#[tauri::command]
pub async fn send_text_message_handler(
    params: SendMessageParams,
    state: State<'_, DbConn>,
) -> Result<i64, String> {
    let db = state.inner();
    ChatService::send_message(db, params)
        .await
        .map_err(|e| e.to_string())
}
```

**步骤 2.4：添加单元测试**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_send_message() {
        // TODO: 添加测试
    }

    #[tokio::test]
    async fn test_get_messages() {
        // TODO: 添加测试
    }
}
```

#### 验收标准

- [ ] 所有聊天功能正常工作（发送、接收、已读、删除）
- [ ] IPC 层只做参数转换（检查 `ipc/chat.rs` 无业务逻辑）
- [ ] Service 方法有单元测试，覆盖率 > 80%
- [ ] 所有现有测试通过
- [ ] `cargo clippy` 无警告

#### 回滚方案

恢复 `ipc/chat.rs` 的原始版本，删除或禁用 Service 实现

---

### 阶段 3：迁移文件业务逻辑（2-3 天）

#### 目标

将 `ipc/file.rs` 的业务逻辑迁移到 `FileService`

#### 具体步骤

（类似阶段 2，针对文件模块）

1. 实现 `FileService::send_file_request`
2. 实现 `FileService::accept_file`
3. 实现 `FileService::reject_file`
4. 实现 `FileService::cancel_transfer`
5. 重构 `ipc/file.rs` 为薄层
6. 添加单元测试

#### 验收标准

- [ ] 所有文件功能正常工作（发送、接收、取消）
- [ ] IPC 层只做参数转换
- [ ] 单元测试覆盖率 > 80%
- [ ] 所有现有测试通过

#### 回滚方案

恢复 `ipc/file.rs` 的原始版本

---

### 阶段 4：迁移用户和联系人业务逻辑（1-2 天）

#### 目标

将 `ipc/user.rs` 和 `ipc/contact.rs` 的业务逻辑迁移

#### 具体步骤

（类似阶段 2）

1. 实现 `ContactService` 所有方法
2. 实现 `UserService` 所有方法
3. 重构 `ipc/contact.rs`
4. 重构 `ipc/user.rs`
5. 添加单元测试

#### 验收标准

- [ ] 所有功能正常工作
- [ ] IPC 层只做参数转换
- [ ] 所有现有测试通过

#### 回滚方案

恢复相关 IPC 文件的原始版本

---

### 阶段 5：统一错误处理（2-3 天）

#### 目标

创建结构化错误类型，前端可以区分错误类型

#### 具体步骤

**步骤 5.1：创建 FrontendError 类型**

```rust
// src-tauri/src/types/error.rs
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FrontendError {
    pub code: ErrorCode,
    pub message: String,
    pub details: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum ErrorCode {
    DatabaseError,
    NetworkError,
    NotFound,
    AlreadyExists,
    BusinessError,
    ValidationError,
    PermissionDenied,
}

impl std::fmt::Display for FrontendError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{:?}] {}", self.code, self.message)
    }
}

impl std::error::Error for FrontendError {}

impl From<AppError> for FrontendError {
    fn from(err: AppError) -> Self {
        match err {
            AppError::Database(e) => FrontendError {
                code: ErrorCode::DatabaseError,
                message: "数据库操作失败".to_string(),
                details: Some(e.to_string()),
            },
            AppError::Network(msg) => FrontendError {
                code: ErrorCode::NetworkError,
                message: "网络操作失败".to_string(),
                details: Some(msg),
            },
            AppError::NotFound(what) => FrontendError {
                code: ErrorCode::NotFound,
                message: format!("{} 不存在", what),
                details: None,
            },
            AppError::AlreadyExists(what) => FrontendError {
                code: ErrorCode::AlreadyExists,
                message: format!("{} 已存在", what),
                details: None,
            },
            _ => FrontendError {
                code: ErrorCode::BusinessError,
                message: err.to_string(),
                details: None,
            },
        }
    }
}
```

**步骤 5.2：修改 IPC 命令返回类型**

```rust
// 将所有 IPC 命令的返回类型从 Result<T, String> 改为 Result<T, FrontendError>

#[tauri::command]
pub async fn send_text_message_handler(
    params: SendMessageParams,
    state: State<'_, DbConn>,
) -> Result<i64, FrontendError> {
    let db = state.inner();
    ChatService::send_message(db, params).await?
}
```

**步骤 5.3：创建前端错误处理工具**

```typescript
// src/utils/error.ts
export interface FrontendError {
  code: ErrorCode;
  message: string;
  details?: string;
}

export enum ErrorCode {
  DatabaseError = 'DatabaseError',
  NetworkError = 'NetworkError',
  NotFound = 'NotFound',
  AlreadyExists = 'AlreadyExists',
  BusinessError = 'BusinessError',
  ValidationError = 'ValidationError',
  PermissionDenied = 'PermissionDenied',
}

export function showError(error: FrontendError) {
  switch (error.code) {
    case ErrorCode.NetworkError:
      toast.error('网络错误：' + error.message);
      break;
    case ErrorCode.DatabaseError:
      toast.error('数据库错误：' + error.message);
      break;
    case ErrorCode.NotFound:
      toast.error(error.message);
      break;
    default:
      toast.error(error.message);
  }
}
```

#### 验收标准

- [ ] 前端可以区分错误类型
- [ ] 所有 IPC 命令使用 `FrontendError`
- [ ] 错误信息友好且可读
- [ ] 前端有统一的错误处理

#### 回滚方案

恢复 IPC 命令的原始返回类型

---

### 阶段 6：升级 SeaORM 并修复数据库迁移（0.5-1 天）

#### 目标

升级到 SeaORM 2.0.0-rc.30（最新版本）并修复迁移系统

**SeaORM 版本信息**：

- 当前版本：0.12
- 目标版本：2.0.0-rc.30
- 发布时间：2026年1月

**主要变化**（来自 SeaORM 2.0）：

- `ExprTrait` 必须在作用域中导入
- 更强的类型系统
- 新的实体格式支持
- sqlx 升级到 0.9
- 更好的开发体验

#### 具体步骤

**步骤 6.0：升级 SeaORM 到 2.0.0-rc.30**

```bash
# 更新 Cargo.toml 中的 SeaORM 依赖
sea-orm = { version = "2.0.0-rc.30", features = [
    "sqlx-sqlite",
    "runtime-tokio-rustls",
    "macros",
    "with-chrono",
    "with-uuid",
    "with-json",
    "debug-print",
] }
sea-orm-migration = { version = "2.0.0-rc.30", features = [
    "sqlx-sqlite",
    "runtime-tokio-rustls",
] }
```

**步骤 6.1：修复代码中的破坏性变更**

SeaORM 2.0 的主要破坏性变更：

1. **添加 `ExprTrait` 导入**：

   ```rust
   // 在使用 Expr::col(), Expr::val() 等方法的文件中添加
   use sea_orm::ExprTrait;
   ```

2. **类型系统变化**：
   - `.eq()` 等方法的参数类型更严格
   - 检查所有 `.and_where()`, `.filter()` 等链式调用

3. **迁移 API 变化**：
   - 确保 `MigratorTrait` 的实现正确

**步骤 6.2：修复迁移调用**

```rust
// src-tauri/src/database/mod.rs

pub async fn init_database(db_path: Option<&str>) -> AppResult<DbConn> {
    // ... 现有代码 ...

    // 修复：迁移失败必须终止启动
    tracing::info!("正在运行数据库迁移...");
    crate::database::migration::Migrator::up(&db, None)
        .await
        .map_err(|e| {
            tracing::error!("数据库迁移失败: {}", e);
            AppError::Database(e)
        })?;
    tracing::info!("数据库迁移完成");

    // ...
}
```

**步骤 6.2：移除注释的原生 SQL 代码**
删除 `database/mod.rs` 中 L57-332 的注释代码

#### 验收标准

- [ ] `cargo check` 编译通过，无 SeaORM 相关错误
- [ ] 所有使用 `Expr` 的文件导入了 `ExprTrait`
- [ ] 迁移失败时应用终止
- [ ] 迁移成功时表正确创建
- [ ] 所有数据库测试通过
- [ ] SeaORM 版本为 2.0.0-rc.30（通过 `cargo tree` 验证）

#### 回滚方案

恢复原始的迁移调用代码

---

### 阶段 7：重构事件系统（2-3 天）

#### 目标

细化事件类型，实现事件订阅者模式

#### 具体步骤

**步骤 7.1：细化事件类型**

```rust
// src-tauri/src/event/model.rs

#[derive(Debug, Clone)]
pub enum NetworkEvent {
    PacketReceived { packet: FeiqPacket, addr: SocketAddr },
    // 新增细粒度事件
    MessageReceived {
        from_uid: i64,
        content: String,
        msg_no: String,
    },
    UserOnline {
        user: UserInfo,
    },
    UserOffline {
        feiq_ip: String,
    },
    ReadReceiptReceived {
        msg_no: String,
        from_uid: i64,
    },
}
```

**步骤 7.2：修改网络接收器**

```rust
// src-tauri/src/network/udp/receiver.rs

// 在收到包后，解析并发布细粒度事件
if packet.command == IPMSG_SENDMSG {
    // 发布细粒度事件
    EVENT_SENDER.send(AppEvent::Network(NetworkEvent::MessageReceived {
        from_uid: packet.sender_uid,
        content: packet.content,
        msg_no: packet.msg_no,
    }))?;
} else if packet.command == IPMSG_BR_ENTRY {
    EVENT_SENDER.send(AppEvent::Network(NetworkEvent::UserOnline {
        user: user_info,
    }))?;
}
```

**步骤 7.3：实现事件订阅者模式**

```rust
// src-tauri/src/event/subscriber.rs

pub trait EventSubscriber {
    fn filter(&self, event: &AppEvent) -> bool;
    fn handle(&self, event: AppEvent);
}

pub struct EventLoop {
    subscribers: Vec<Box<dyn EventSubscriber>>,
}

impl EventLoop {
    pub fn new() -> Self {
        Self {
            subscribers: Vec::new(),
        }
    }

    pub fn register(&mut self, subscriber: Box<dyn EventSubscriber>) {
        self.subscribers.push(subscriber);
    }

    pub async fn run(&self) {
        loop {
            let event = EVENT_RECEIVER.recv().unwrap();
            for subscriber in &self.subscribers {
                if subscriber.filter(&event) {
                    subscriber.handle(event.clone());
                }
            }
        }
    }
}
```

**步骤 7.4：修复主事件循环**

```rust
// src-tauri/src/main.rs

// 创建事件循环并注册订阅者
let mut event_loop = EventLoop::new();

// 注册聊天订阅者
event_loop.register(Box::new(ChatSubscriber::new(db)));

// 运行事件循环
tokio::spawn(async move {
    event_loop.run().await;
});
```

#### 验收标准

- [ ] 事件粒度合理（订阅者无需过滤）
- [ ] 订阅者模式正常工作
- [ ] 事件流完整到达前端 UI
- [ ] 所有事件测试通过

#### 回滚方案

恢复原始事件系统和事件循环

---

### 阶段 8：前端架构优化（2-3 天）

#### 目标

统一状态管理，创建 IPC 调用抽象层

#### 具体步骤

**步骤 8.1：创建 IPC 客户端**

```typescript
// src/ipc/client.ts
import { invoke } from '@tauri-apps/api/tauri';
import type { FrontendError } from './types';

export class IPCClient {
  private pendingRequests = new Map<string, AbortController>();

  async invoke<T>(
    command: string,
    params: unknown = {},
    options?: { signal?: AbortSignal }
  ): Promise<T> {
    const requestId = `${command}-${Date.now()}`;

    if (options?.signal) {
      const controller = new AbortController();
      this.pendingRequests.set(requestId, controller);

      options.signal.addEventListener('abort', () => {
        controller.abort();
        this.pendingRequests.delete(requestId);
      });
    }

    try {
      return await invoke<T>(command, params);
    } catch (error) {
      const err = error as FrontendError;
      throw err;
    } finally {
      this.pendingRequests.delete(requestId);
    }
  }

  cancelAll() {
    this.pendingRequests.forEach((controller) => controller.abort());
    this.pendingRequests.clear();
  }
}

export const ipcClient = new IPCClient();
```

**步骤 8.2：创建 API 调用 Hook**

```typescript
// src/hooks/useApi.ts
import { useStore } from './store';
import { ipcClient } from '../ipc/client';

export function useApi() {
  const { showError } = useStore();

  async function sendTextMessage(params: SendMessageParams): Promise<number> {
    try {
      return await ipcClient.invoke<number>('send_text_message', params);
    } catch (error) {
      showError(error as FrontendError);
      throw error;
    }
  }

  // 其他 API 方法...

  return {
    sendTextMessage,
    // ...
  };
}
```

**步骤 8.3：重构 Store 层**

```typescript
// 移除 Store 层的 IPC 调用
// Store 只负责状态管理

export const useChatStore = create<ChatStore>((set) => ({
  messages: new Map(),
  sessions: new Map(),

  // 移除 IPC 调用
  sendMessage: async (params) => {
    // 不再直接调用 IPC
    // 应该在 Hook 层调用
  },
}));
```

**步骤 8.4：添加错误边界**

```typescript
// src/components/ErrorBoundary.tsx
import React from 'react';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export class ErrorBoundary extends React.Component<Props, { hasError: boolean }> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>出错了</div>;
    }
    return this.props.children;
  }
}
```

#### 验收标准

- [ ] 状态管理统一（Store 不包含 IPC 调用）
- [ ] IPC 调用无重复（通过 IPCClient 统一）
- [ ] 组件职责单一
- [ ] 所有前端测试通过
- [ ] 支持请求取消

#### 回滚方案

恢复前端原始实现

---

## 四、兼容性保障措施

### 4.1 IPC 接口兼容性

**策略**：保持所有 IPC 命令签名不变

**实现**：

- IPC 命令的参数类型和返回类型保持不变
- 在 IPC 层内部调用 Service，外部接口不变
- 使用 `FrontendError` 时提供兼容层（如果需要）

**验证**：

- 每个阶段后运行前端测试
- 对比 IPC 接口定义，确保无破坏性变更

### 4.2 渐进式迁移策略

**原则**：

- 一次迁移一个模块
- 每个模块迁移后验证
- 发现问题立即回滚

**流程**：

1. 创建新 Service（不影响现有代码）
2. 逐步迁移业务逻辑
3. 重构 IPC 层调用 Service
4. 测试验证
5. 提交并标记里程碑
6. 遇到问题立即回滚到上一个里程碑

### 4.3 测试策略

**单元测试**：

- Service 层每个方法都有单元测试
- 测试覆盖正常流程和异常情况
- 使用 Mock 隔离数据库和网络依赖

**集成测试**：

- 端到端功能测试
- 测试完整业务流程
- 使用测试数据库

**回归测试**：

- 每个阶段后运行所有现有测试
- 确保现有功能不被破坏
- 性能测试基准对比

---

## 五、风险评估

| 风险                      | 影响 | 概率 | 缓解措施                             |
| ------------------------- | ---- | ---- | ------------------------------------ |
| Service 层设计不合理      | 高   | 中   | 先创建骨架，评审后再实现             |
| IPC 接口意外改变          | 高   | 低   | 每次提交前对比接口                   |
| 性能下降                  | 中   | 低   | 性能测试基准对比                     |
| 前端无法适配新错误格式    | 中   | 中   | 提供迁移指南和兼容层                 |
| 数据库迁移失败            | 高   | 低   | 充分测试，有备份                     |
| 事件系统重构引入新 bug    | 高   | 中   | 充分测试，保持向后兼容               |
| 前端状态管理混乱          | 中   | 低   | 先设计再实现                         |
| SeaORM 2.0 升级破坏性变更 | 高   | 中   | 仔细阅读迁移指南，按步骤修复编译错误 |

---

## 六、时间估算

| 阶段                           | 预估时间 | 难度 | 风险 |
| ------------------------------ | -------- | ---- | ---- |
| 阶段 1：Service 层骨架         | 1-2 天   | 低   | 低   |
| 阶段 2：聊天业务逻辑迁移       | 2-3 天   | 高   | 中   |
| 阶段 3：文件业务逻辑迁移       | 2-3 天   | 高   | 中   |
| 阶段 4：用户和联系人迁移       | 1-2 天   | 中   | 低   |
| 阶段 5：统一错误处理           | 2-3 天   | 中   | 中   |
| 阶段 6：升级 SeaORM 并修复迁移 | 0.5-1 天 | 中   | 中   |
| 阶段 7：重构事件系统           | 2-3 天   | 高   | 高   |
| 阶段 8：前端架构优化           | 2-3 天   | 中   | 中   |

**总计**：**13.5-20 天**（约 2-3 周）

**时间分配建议**：

- 高风险阶段：安排在项目前期，预留更多时间
- 低风险阶段：可以快速推进
- 机动时间：预留 3-5 天应对意外情况

---

## 七、成功标准

### 7.1 代码质量

- [ ] 所有 Service 层代码通过 `cargo clippy`，无警告
- [ ] 代码覆盖率 > 80%（单元测试 + 集成测试）
- [ ] 无重复代码（通过工具检测）
- [ ] 代码符合 Rust 最佳实践和 Clippy 建议

### 7.2 架构清晰

- [ ] IPC 层只做参数转换和错误映射（< 50 行每个命令）
- [ ] Service 层包含所有业务逻辑（不包含数据库直接操作）
- [ ] 层次边界清晰，依赖方向正确（前端 → IPC → Service → Repository）
- [ ] 事件粒度合理，订阅者无需过滤

### 7.3 兼容性

- [ ] 所有现有功能正常工作（端到端测试通过）
- [ ] IPC 接口保持不变（前端无需修改接口调用）
- [ ] 前端只需修改错误处理逻辑
- [ ] 数据库迁移向后兼容

### 7.4 可维护性

- [ ] 新功能开发更容易（清晰的 Service 接口）
- [ ] Bug 修复更简单（职责明确）
- [ ] 代码审查更高效（代码结构清晰）
- [ ] 文档完整（README、代码注释、API 文档）

---

## 八、附录

### A. 关键设计决策

**决策 1：为什么创建 Service 层？**

- **问题**：业务逻辑泄露到 IPC 层，导致代码难以维护和测试
- **方案**：创建 Service 层封装业务逻辑
- **理由**：分层架构是业界最佳实践，职责清晰，易于测试

**决策 2：为什么使用 FrontendError？**

- **问题**：错误通过 `.to_string()` 转换，丢失类型信息
- **方案**：创建结构化错误类型 `FrontendError`
- **理由**：前端可以区分错误类型，提供更好的用户体验

**决策 3：为什么细化事件类型？**

- **问题**：`PacketReceived` 事件粒度太粗，订阅者需要自己解析
- **方案**：在发布时解析包，发布细粒度事件
- **理由**：减少订阅者的负担，提高事件系统的效率

**决策 4：为什么保持 IPC 接口不变？**

- **问题**：前端依赖 IPC 接口，改变会导致大面积修改
- **方案**：在 IPC 层内部重构，外部接口保持不变
- **理由**：降低重构风险，保持向后兼容

### B. 代码示例

**示例 B.1：Service 层方法签名**

```rust
pub async fn send_message(
    db: &DbConn,
    params: SendMessageParams,
) -> AppResult<i64>
```

**示例 B.2：IPC 层命令**

```rust
#[tauri::command]
pub async fn send_text_message_handler(
    params: SendMessageParams,
    state: State<'_, DbConn>,
) -> Result<i64, FrontendError> {
    let db = state.inner();
    ChatService::send_message(db, params).await?
}
```

**示例 B.3：前端错误处理**

```typescript
try {
  await sendTextMessage(params);
} catch (error) {
  showError(error as FrontendError);
}
```

### C. 参考资料

- [Rust 最佳实践](https://rust-lang.github.io/api-guidelines/)
- [Tauri 文档](https://tauri.app/)
- [SeaORM 文档](https://www.sea-ql.org/SeaORM/)
- [SeaORM 2.0 迁移指南](https://www.sea-ql.org/blog/2026-01-12-sea-orm-2.0/)
- [SeaORM 2.0 新功能](https://www.sea-ql.org/SeaORM/docs/introduction/whats-new/)
- [React 最佳实践](https://react.dev/learn)
- [架构模式：分层架构](https://martinfowler.com/bliki/PresentationDomainDataLayering.html)

---

**文档结束**
